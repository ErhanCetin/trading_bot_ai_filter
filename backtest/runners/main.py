"""
Ana √ßalƒ±≈ütƒ±rƒ±cƒ± mod√ºl - VSCode'dan doƒürudan √ßalƒ±≈ütƒ±rƒ±labilir
ENHANCED: Added comprehensive validation, analysis and error handling
"""
import os
import sys
import json
from typing import Dict, List, Any, Optional
import logging

# Mod√ºl yolunu ayarla - mevcut dizinin bir √ºst dizinini Python yoluna ekle
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

# Loglama yapƒ±landƒ±rmasƒ±
logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Backtest mod√ºllerini i√ße aktar
from backtest.utils.config_loader import load_env_config
from backtest.runners.single_backtest import run_single_backtest
from backtest.runners.batch_backtest import run_batch_backtest
from backtest.utils.config_viewer import print_config_details, print_enhanced_config_summary
from backtest.utils.signal_engine_components import check_signal_engine_components

def print_registered_indicators():
    """
    Kayƒ±tlƒ± indikat√∂rleri g√∂sterir
    """
    # Bu kodu bir yerde √ßalƒ±≈ütƒ±rƒ±n (√∂rneƒüin main.py dosyasƒ±na ekleyin)

    from backtest.utils.indicator_helper import check_available_indicators, get_recommended_config

    # Kullanƒ±labilir indikat√∂rleri g√∂ster
    available = check_available_indicators()
    print(f"Found {len(available)} indicators in registry.\n")

    # Tavsiye edilen yapƒ±landƒ±rmayƒ± al
    recommended = get_recommended_config()

    print("\nRECOMMENDED CONFIGURATION:")
    print("=" * 80)
    print(recommended["recommended_env"])
    print("=" * 80)
    print("\nThis configuration includes only the indicators available in the Signal Engine registry.")

def validate_backtest_config(env_config: Dict[str, Any]) -> List[str]:
    """
    ENHANCED: Validate backtest configuration and return warnings
    
    Args:
        env_config: Environment configuration
        
    Returns:
        List of validation warnings
    """
    warnings = []
    
    # Risk validation
    risk_per_trade = float(env_config.get("risk_per_trade", 0.01))
    if risk_per_trade > 0.05:
        warnings.append(f"‚ö†Ô∏è High risk per trade: {risk_per_trade*100:.1f}% (recommended: <5%)")
    elif risk_per_trade < 0.005:
        warnings.append(f"‚ö†Ô∏è Very low risk per trade: {risk_per_trade*100:.1f}% (may limit profits)")
    
    # Leverage validation
    leverage = float(env_config.get("leverage", 1.0))
    if leverage > 10:
        warnings.append(f"‚ö†Ô∏è Very high leverage: {leverage}x (increases risk significantly)")
    elif leverage > 5:
        warnings.append(f"‚ö†Ô∏è High leverage: {leverage}x (use with caution)")
    
    # SL/TP ratio validation
    sl_mult = float(env_config.get("sl_multiplier", 1.5))
    tp_mult = float(env_config.get("tp_multiplier", 3.0))
    rr_ratio = tp_mult / sl_mult
    
    if rr_ratio < 1.5:
        warnings.append(f"‚ö†Ô∏è Low Risk/Reward ratio: {rr_ratio:.2f} (recommended: >1.5)")
    elif rr_ratio > 5:
        warnings.append(f"‚ö†Ô∏è Very high Risk/Reward ratio: {rr_ratio:.2f} (may reduce win rate)")
    
    # Position direction validation
    pos_dir = env_config.get("position_direction", {})
    if not pos_dir.get("Long", True) and not pos_dir.get("Short", True):
        warnings.append("‚ùå Both Long and Short disabled - no trades will be executed")
    
    # Commission validation
    commission = float(env_config.get("commission_rate", 0.001))
    if commission > 0.005:
        warnings.append(f"‚ö†Ô∏è High commission rate: {commission*100:.3f}% (may impact profitability)")
    
    # Symbol and interval validation
    symbol = env_config.get("symbol")
    interval = env_config.get("interval")
    if not symbol:
        warnings.append("‚ùå Symbol not configured")
    if not interval:
        warnings.append("‚ùå Interval not configured")
    
    # Database URL validation
    db_url = env_config.get("db_url")
    if not db_url:
        warnings.append("‚ùå Database URL not configured")
    
    # Initial balance validation
    initial_balance = float(env_config.get("initial_balance", 10000))
    if initial_balance < 1000:
        warnings.append(f"‚ö†Ô∏è Low initial balance: ${initial_balance:,.2f} (may affect position sizing)")
    
    return warnings

def calculate_risk_score(metrics: Dict[str, Any]) -> float:
    """
    ENHANCED: Calculate risk score (0-10, lower is better)
    """
    score = 5.0  # Base score
    
    # Drawdown penalty
    max_dd = metrics.get('max_drawdown_pct', 0)
    if max_dd > 20:
        score += 3
    elif max_dd > 10:
        score += 2
    elif max_dd > 5:
        score += 1
    
    # Sharpe ratio bonus
    sharpe = metrics.get('sharpe_ratio', 0)
    if sharpe > 2:
        score -= 2
    elif sharpe > 1:
        score -= 1
    elif sharpe < 0:
        score += 2
    
    # Profit factor consideration
    pf = metrics.get('profit_factor', 0)
    if pf < 1:
        score += 2
    elif pf > 2:
        score -= 1
    
    # Consecutive losses penalty
    max_consec_loss = metrics.get('max_consecutive_losses', 0)
    if max_consec_loss > 10:
        score += 2
    elif max_consec_loss > 5:
        score += 1
    
    return max(0, min(10, score))

def calculate_performance_rating(result: Dict[str, Any], metrics: Dict[str, Any]) -> float:
    """
    ENHANCED: Calculate performance rating (0-10, higher is better)
    """
    score = 5.0  # Base score
    
    # ROI bonus/penalty
    roi = result.get('roi_pct', 0)
    if roi > 50:
        score += 3
    elif roi > 20:
        score += 2
    elif roi > 10:
        score += 1
    elif roi < 0:
        score -= 3
    elif roi < 5:
        score -= 1
    
    # Win rate bonus
    win_rate = metrics.get('win_rate', 0)
    if win_rate > 70:
        score += 2
    elif win_rate > 60:
        score += 1
    elif win_rate < 40:
        score -= 1
    elif win_rate < 30:
        score -= 2
    
    # Trade count consideration
    total_trades = result.get('total_trades', 0)
    if total_trades < 10:
        score -= 2  # Not enough trades for reliable statistics
    elif total_trades > 100:
        score += 1  # Good sample size
    
    # Profit factor bonus
    pf = metrics.get('profit_factor', 0)
    if pf > 2:
        score += 1
    elif pf > 1.5:
        score += 0.5
    
    # Risk-adjusted return (Sharpe ratio)
    sharpe = metrics.get('sharpe_ratio', 0)
    if sharpe > 2:
        score += 1
    elif sharpe > 1:
        score += 0.5
    
    return max(0, min(10, score))

def get_risk_level(score: float) -> str:
    """Get risk level description"""
    if score <= 3:
        return "LOW RISK"
    elif score <= 6:
        return "MODERATE RISK"
    elif score <= 8:
        return "HIGH RISK"
    else:
        return "VERY HIGH RISK"

def get_performance_level(score: float) -> str:
    """Get performance level description"""
    if score >= 8:
        return "EXCELLENT"
    elif score >= 6:
        return "GOOD"
    elif score >= 4:
        return "AVERAGE"
    elif score >= 2:
        return "POOR"
    else:
        return "VERY POOR"

def analyze_backtest_results(result: Dict[str, Any]) -> None:
    """
    ENHANCED: result analysis with detailed breakdown
    
    Args:
        result: Backtest result dictionary
    """
    if result.get("status") != "success":
        print(f"‚ùå Backtest failed: {result.get('message', 'Unknown error')}")
        return
    
    backtest_result = result.get("result", {})
    metrics = backtest_result.get("metrics", {})
    
    print("\n" + "="*80)
    print("üìä ENHANCED BACKTEST RESULTS ANALYSIS")
    print("="*80)
    
    # Core Performance Metrics
    print(f"\nüéØ CORE PERFORMANCE:")
    print(f"   Total Trades: {backtest_result.get('total_trades', 0)}")
    print(f"   Win Rate: {metrics.get('win_rate', 0):.2f}%")
    print(f"   Profit Factor: {metrics.get('profit_factor', 0):.2f}")
    print(f"   ROI: {backtest_result.get('roi_pct', 0):.2f}%")
    print(f"   Net Profit: ${backtest_result.get('profit_loss', 0):.2f}")
    
    # Financial Details
    print(f"\nüí∞ FINANCIAL BREAKDOWN:")
    print(f"   Gross Profit: ${metrics.get('gross_profit', 0):.2f}")
    print(f"   Gross Loss: ${metrics.get('gross_loss', 0):.2f}")
    print(f"   Winning Trades: {metrics.get('winning_trades', 0)}")
    print(f"   Losing Trades: {metrics.get('losing_trades', 0)}")
    if metrics.get('winning_trades', 0) > 0:
        print(f"   Average Win: ${metrics.get('average_win', 0):.2f}")
    if metrics.get('losing_trades', 0) > 0:
        print(f"   Average Loss: ${metrics.get('average_loss', 0):.2f}")
    
    # Risk Metrics
    print(f"\n‚ö†Ô∏è RISK METRICS:")
    print(f"   Max Drawdown: {metrics.get('max_drawdown_pct', 0):.2f}%")
    print(f"   Sharpe Ratio: {metrics.get('sharpe_ratio', 0):.2f}")
    print(f"   Sortino Ratio: {metrics.get('sortino_ratio', 0):.2f}")
    print(f"   Calmar Ratio: {metrics.get('calmar_ratio', 0):.2f}")
    print(f"   Recovery Factor: {metrics.get('recovery_factor', 0):.2f}")
    print(f"   VaR (95%): {metrics.get('var_95', 0):.2f}%")
    print(f"   Max Consecutive Losses: {metrics.get('max_consecutive_losses', 0)}")
    print(f"   Max Consecutive Wins: {metrics.get('max_consecutive_wins', 0)}")
    
    # Direction Performance
    if 'direction_performance' in metrics:
        print(f"\nüìà DIRECTION PERFORMANCE:")
        for direction, stats in metrics['direction_performance'].items():
            print(f"   {direction}:")
            print(f"     Trades: {stats.get('count', 0)}")
            print(f"     Win Rate: {stats.get('win_rate', 0):.2f}%")
            print(f"     Total PnL: ${stats.get('total_pnl', 0):.2f}")
            print(f"     Avg Trade: ${stats.get('avg_pnl', 0):.2f}")
            print(f"     Profit Factor: {stats.get('profit_factor', 0):.2f}")
    
    # Trade Quality Analysis
    if backtest_result.get('total_trades', 0) > 0:
        print(f"\nüîç TRADE QUALITY:")
        avg_win = metrics.get('average_win', 0)
        avg_loss = metrics.get('average_loss', 0)
        print(f"   Average Win: ${avg_win:.2f}")
        print(f"   Average Loss: ${avg_loss:.2f}")
        print(f"   Win/Loss Ratio: {abs(avg_win/avg_loss):.2f}" if avg_loss != 0 else "   Win/Loss Ratio: ‚àû")
        print(f"   Largest Win: ${metrics.get('largest_win', 0):.2f}")
        print(f"   Largest Loss: ${metrics.get('largest_loss', 0):.2f}")
        print(f"   Average R:R Ratio: {metrics.get('avg_rr_ratio', 0):.2f}")
        
        # Outcome distribution
        if 'outcome_distribution' in metrics:
            print(f"\nüìä OUTCOME DISTRIBUTION:")
            total_outcomes = sum(metrics['outcome_distribution'].values())
            for outcome, count in metrics['outcome_distribution'].items():
                pct = (count / total_outcomes * 100) if total_outcomes > 0 else 0
                print(f"   {outcome}: {count} ({pct:.1f}%)")
    
    # Risk Assessment
    print(f"\nüö® RISK ASSESSMENT:")
    risk_score = calculate_risk_score(metrics)
    print(f"   Risk Score: {risk_score:.1f}/10 ({get_risk_level(risk_score)})")
    
    # Performance Rating
    performance_rating = calculate_performance_rating(backtest_result, metrics)
    print(f"   Performance Rating: {performance_rating:.1f}/10 ({get_performance_level(performance_rating)})")
    
    # Trading Period
    if 'trading_period' in metrics:
        period = metrics['trading_period']
        print(f"\nüìÖ TRADING PERIOD:")
        print(f"   Start: {period.get('start', 'Unknown')}")
        print(f"   End: {period.get('end', 'Unknown')}")
        print(f"   Duration: {period.get('duration_days', 0)} days")
    
    # Configuration Summary
    config = backtest_result.get('config', {})
    if config:
        print(f"\n‚öôÔ∏è CONFIGURATION:")
        print(f"   Risk per Trade: {config.get('risk_per_trade', 0)*100:.2f}%")
        pos_dir = config.get('position_direction', {})
        directions = []
        if pos_dir.get('Long', False):
            directions.append('Long')
        if pos_dir.get('Short', False):
            directions.append('Short')
        print(f"   Directions: {', '.join(directions) if directions else 'None'}")


def run_backtest(mode: str = "single", config_id: str = "default", custom_config: Dict[str, Any] = None):
    """
    ENHANCED: Backtest √ßalƒ±≈ütƒ±rƒ±r - VSCode'dan direkt √ßaƒürƒ±labilir with validation and analysis
    
    Args:
        mode: √áalƒ±≈ütƒ±rma modu ("single" veya "batch")
        config_id: Konfig√ºrasyon ID'si (single mod i√ßin)
        custom_config: √ñzel konfig√ºrasyon s√∂zl√ºƒü√º (varsayƒ±lanlarƒ± ezmek i√ßin)
    """
    # √áevre deƒüi≈ükenlerinden konfig√ºrasyon y√ºkle
    env_config = load_env_config()
    #print_config_details(env_config, "BACKTEST CONFIGURATION")

    #print_registered_indicators()
    #check_signal_engine_components()

    # √ñzel konfig√ºrasyonu entegre et (varsa)
    if custom_config:
        for key, value in custom_config.items():
            env_config[key] = value
    
    # ENHANCED: Configuration validation
    config_warnings = validate_backtest_config(env_config)
    if config_warnings:
        print("\nüö® CONFIGURATION WARNINGS:")
        for warning in config_warnings:
            print(f"   {warning}")
        print("")
    
    # ENHANCED: Print configuration summary
    print_enhanced_config_summary(env_config)
    
    # √áƒ±ktƒ± dizini olu≈ütur
    output_dir = env_config.get("results_dir", "backtest/results")
    os.makedirs(output_dir, exist_ok=True)
    
    # Gerekli parametreleri kontrol et
    symbol = env_config.get("symbol")
    interval = env_config.get("interval")
    
    if not symbol or not interval:
        logger.error("Symbol ve interval parametreleri gerekli. L√ºtfen ENV dosyasƒ±nƒ± kontrol edin.")
        return
    backtest_params = {
        "initial_balance": env_config.get("initial_balance"),
        "risk_per_trade": env_config.get("risk_per_trade"),
        "sl_multiplier": env_config.get("sl_multiplier"),
        "tp_multiplier": env_config.get("tp_multiplier"),
        "leverage": env_config.get("leverage"),
        "position_direction": env_config.get("position_direction"),
        "commission_rate": env_config.get("commission_rate"),
        "max_holding_bars": env_config.get("max_holding_bars", 500),
        
        # ‚úÖ TP/Commission filter parameters
        "min_tp_commission_ratio": env_config.get("min_tp_commission_ratio", 3.0),
        "max_commission_impact_pct": env_config.get("max_commission_impact_pct", 15.0),
        "min_position_size": env_config.get("min_position_size", 800.0),
        "min_net_rr_ratio": env_config.get("min_net_rr_ratio", 1.5),
        "enable_tp_commission_filter": env_config.get("enable_tp_commission_filter", False)
    }

    # ‚úÖ VALIDATION: Check if filter parameters are being passed correctly
    logger.info("üîß Backtest Parameters Validation:")
    logger.info(f"   enable_tp_commission_filter: {backtest_params.get('enable_tp_commission_filter')}")
    logger.info(f"   commission_rate: {backtest_params.get('commission_rate')}")
    logger.info(f"   min_tp_commission_ratio: {backtest_params.get('min_tp_commission_ratio')}")
    logger.info(f"   max_commission_impact_pct: {backtest_params.get('max_commission_impact_pct')}")
    logger.info(f"   min_position_size: {backtest_params.get('min_position_size')}")
    logger.info(f"   min_net_rr_ratio: {backtest_params.get('min_net_rr_ratio')}")
    
    if mode == "single":
        logger.info(f"üöÄ {symbol} {interval} i√ßin tek backtest √ßalƒ±≈ütƒ±rƒ±lƒ±yor (Config ID: {config_id})")
         # ‚úÖ TP/Commission filter status
        if backtest_params.get("enable_tp_commission_filter", False):
            logger.info("üîß TP/Commission filter ENABLED - Only profitable trades will be opened")
        else:
            logger.info("‚ö†Ô∏è TP/Commission filter DISABLED - All valid signals will be processed")
        # Tek backtest √ßalƒ±≈ütƒ±r
        result = run_single_backtest(
            symbol=symbol,
            interval=interval,
            db_url=env_config.get("db_url"),
            output_dir=os.path.join(output_dir, "single"),
            backtest_params=backtest_params,  # ‚úÖ TP/Commission parameters dahil
            indicators_config=env_config.get("indicators"),
            config_id=config_id
        )
        
        if result.get("status") == "success":
            logger.info(f"‚úÖ Backtest ba≈üarƒ±yla tamamlandƒ±. Sonu√ßlar: {output_dir}/single klas√∂r√ºne kaydedildi.")
            
            # ENHANCED: Comprehensive result analysis
            analyze_backtest_results(result)
            
            # Kƒ±sa √∂zet yazdƒ±r (mevcut kod korundu ama enhanced analysis'den sonra)
            logger.info(f"üìÑ Summary saved to output directory for detailed review.")
            return result  
        else:
            logger.error(f"‚ùå Backtest sƒ±rasƒ±nda hata olu≈ütu: {result.get('message')}")
            return None 
    
    elif mode == "batch":
        # Config CSV yolunu belirle
        config_csv = os.path.join("backtest", "config", "config_combinations.csv")
        
        if not os.path.exists(config_csv):
            logger.error(f"‚ùå Konfig√ºrasyon CSV dosyasƒ± bulunamadƒ±: {config_csv}")
            return
        
        logger.info(f"üöÄ CSV konfig√ºrasyonlarƒ± ile toplu backtest √ßalƒ±≈ütƒ±rƒ±lƒ±yor: {config_csv}")

        # ‚úÖ TP/Commission filter status for batch
        if backtest_params.get("enable_tp_commission_filter", False):
            logger.info("üîß BATCH MODE: TP/Commission filter ENABLED for all configurations")
            logger.info(f"   Min TP/Commission ratio: {backtest_params['min_tp_commission_ratio']}x")
            logger.info(f"   Min position size: ${backtest_params['min_position_size']}")
        else:
            logger.info("‚ö†Ô∏è BATCH MODE: TP/Commission filter DISABLED")
        
        # Maksimum i≈ülemci sayƒ±sƒ±nƒ± belirle
        max_workers = os.cpu_count() - 1  # Bir CPU bo≈üta bƒ±rak
        
        auto_fetch = custom_config.get("auto_fetch_data", True) if custom_config else True

        # Toplu backtest √ßalƒ±≈ütƒ±r
        result = run_batch_backtest(
            symbol=symbol,
            interval=interval,
            config_csv_path=config_csv,
            db_url=env_config.get("db_url"),
            output_dir=os.path.join(output_dir, "batch"),
            backtest_params=backtest_params,  # ‚úÖ TP/Commission parameters dahil
            max_workers=max_workers,
            auto_fetch_data=auto_fetch
        )
        
        if result.get("status") == "success":
            logger.info(f"‚úÖ Toplu backtest ba≈üarƒ±yla tamamlandƒ±. Sonu√ßlar: {output_dir}/batch klas√∂r√ºne kaydedildi.")
            logger.info(f"   - Toplam Konfig√ºrasyon: {result.get('total_configs')}")
            logger.info(f"   - Tamamlanan: {result.get('completed_configs')}")
            logger.info(f"   - En ƒ∞yi ROI: {result.get('best_roi_pct'):.2f}% (Config: {result.get('best_roi_config')})")
            logger.info(f"   - En ƒ∞yi Kazan√ß Oranƒ±: {result.get('best_winrate_pct'):.2f}% (Config: {result.get('best_winrate_config')})")
            # ‚úÖ ENHANCED: TP/Commission filter effectiveness
            if result.get('tp_commission_filter_enabled', False):
                filter_stats = result.get('filter_statistics', {})
                logger.info(f"\nüîß TP/COMMISSION FILTER EFFECTIVENESS:")
                logger.info(f"   Total signals: {filter_stats.get('total_signals', 0)}")
                logger.info(f"   Filtered signals: {filter_stats.get('filtered_signals', 0)}")
                logger.info(f"   Configs with trades: {filter_stats.get('configs_with_trades', 0)}")
                logger.info(f"   Configs with no trades: {filter_stats.get('configs_with_no_trades', 0)}")
                
            # ENHANCED: Additional batch statistics
            if result.get('profitable_configs_pct'):
                logger.info(f"   - Karlƒ± Konfig√ºrasyonlar: {result.get('profitable_configs_pct'):.1f}%")
            if result.get('average_roi'):
                logger.info(f"   - Ortalama ROI: {result.get('average_roi'):.2f}%")
            
            return result  # ‚úÖ BUNU EKLE
        else:
            logger.error(f"‚ùå Toplu backtest sƒ±rasƒ±nda hata olu≈ütu: {result.get('message')}")
            return None 
    
    else:
        logger.error(f"‚ùå Bilinmeyen √ßalƒ±≈ütƒ±rma modu: {mode}. 'single' veya 'batch' kullanƒ±n.")
        return None 

def enhanced_run_backtest(mode: str = "single", config_id: str = "default", 
                         custom_config: Dict[str, Any] = None, validate: bool = True):
    """
    ENHANCED: Enhanced backtest runner with validation and detailed analysis
    
    Args:
        mode: Run mode ("single" or "batch")
        config_id: Configuration ID
        custom_config: Custom configuration overrides
        validate: Whether to validate configuration before running
    """
    # Load environment configuration
    env_config = load_env_config()
    
    # Apply custom config
    if custom_config:
        for key, value in custom_config.items():
            env_config[key] = value
    
    # Validate configuration
    if validate:
        warnings = validate_backtest_config(env_config)
        if warnings:
            print("\nüö® CONFIGURATION WARNINGS:")
            for warning in warnings:
                print(f"   {warning}")
            
            # Check for critical errors
            critical_errors = [w for w in warnings if w.startswith("‚ùå")]
            if critical_errors:
                print("\n‚ùå Critical configuration errors found. Please fix before proceeding:")
                for error in critical_errors:
                    print(f"   {error}")
                return None
            
            response = input("\nDo you want to continue? (y/N): ")
            if response.lower() != 'y':
                print("Backtest cancelled.")
                return None
    
    # Run original backtest logic
    result = run_backtest(mode, config_id, custom_config)
    
    return result

if __name__ == "__main__":
    # ENHANCED: VSCode'dan doƒürudan √ßalƒ±≈ütƒ±rmak i√ßin yapƒ±landƒ±rma with validation
    # Burada mod, config_id ve √∂zel parametreler ayarlanabilir
    
    # √áalƒ±≈ütƒ±rma modu: "single" veya "batch"
    RUN_MODE = "batch"  # Tek backtest i√ßin "single", toplu backtest i√ßin "batch"
    
    # Tek backtest i√ßin konfig√ºrasyon ID'si
    CONFIG_ID = "default"
    
    # √ñzel konfig√ºrasyon (√ßevre deƒüi≈ükenlerini ezmek i√ßin)
    CONFIG_ID = "tp_commission_optimized"
    
    # ‚úÖ TP/COMMISSION OPTIMIZE EDƒ∞LMƒ∞≈û KONFIG√úRASYON
    CUSTOM_CONFIG = {
        # üîß CORRECT BINANCE MAKER RATE
           # ‚úÖ REALISTIC COMMISSION
        "commission_rate": 0.0002,  # Binance maker 0.01%
        
        # ‚úÖ AGGRESSIVE RISK MANAGEMENT  
        "risk_per_trade": 0.04,     # %4 risk per trade
        "leverage": 5.0,            # Full 5x leverage
        "initial_balance": 10000.0,
        
        # ‚úÖ TIGHT SL, HIGH TP
        "sl_multiplier": 0.8,       # Very tight SL (0.8x ATR)
        "tp_multiplier": 5.0,       # High TP (6.25:1 R:R ratio)
        
        # ‚úÖ REALISTIC TP/COMMISSION FILTER
        "enable_tp_commission_filter": True,
        "min_tp_commission_ratio": 2.0,      # 2x is enough
        "max_commission_impact_pct": 50.0,   # Up to 50% OK for small trades
        "min_position_size": 50.0,           # $50 minimum (very low)
        "min_net_rr_ratio": 0.8,             # 0.8:1 net (after commission)
        
        # ‚úÖ BOTH DIRECTIONS
        "position_direction": {"Long": True, "Short": True},
        
        # ‚úÖ QUICK SCALPING
        "max_holding_bars": 20,  # 100 minutes max (5m x 20)
        "auto_fetch_data": True,  # Enhanced fetch'i √ßalƒ±≈ütƒ±r

        
        # ‚úÖ RELAXED FILTERS FOR MORE TRADES
        "filters": {
            "market_regime": {},
            "min_checks": 1,        # Only 1 filter check required
            "min_strength": 15      # Very low strength requirement
        }
    }

    # üéØ EXTREME %70+ ROI TARGETING CONFIG
    CUSTOM_CONFIG_EXTREME = {
        # üîß OPTIMIZED COMMISSION
        "commission_rate": 0.0001,  # 0.01% maker (daha d√º≈ü√ºk)
        
        # üîß EXTREME RISK MANAGEMENT
        "risk_per_trade": 0.08,     # %8 risk per trade (was %4)
        "leverage": 15.0,           # 15x leverage (maximum)
        "initial_balance": 10000.0,
        
        # üîß ULTRA TIGHT SL, EXTREME TP
        "sl_multiplier": 0.5,       # √áok sƒ±kƒ± SL (0.5x ATR)
        "tp_multiplier": 12.0,      # √áok y√ºksek TP (24:1 R:R)
        
        # üîß MINIMAL TP/COMMISSION FILTER
        "enable_tp_commission_filter": True,
        "min_tp_commission_ratio": 1.2,      # 1.2x (√ßok gev≈üek)
        "max_commission_impact_pct": 90.0,   # %90'a kadar
        "min_position_size": 20.0,           # $20 minimum
        "min_net_rr_ratio": 0.3,             # 0.3:1 net (√ßok gev≈üek)
        
        # ‚úÖ BOTH DIRECTIONS
        "position_direction": {"Long": True, "Short": True},
        
        # üîß ULTRA FAST SCALPING
        "max_holding_bars": 10,  # 50 dakika max (5m x 10)
        "auto_fetch_data": True,
        
        # üîß MINIMAL FILTERS
        "filters": {
            "min_checks": 1,
            "min_strength": 1  # Minimum possible
        }
    }
    
    CUSTOM_CONFIG = CUSTOM_CONFIG_EXTREME  # Use extreme config for testing

    # ENHANCED: Backtest √ßalƒ±≈ütƒ±r with validation
    print("üöÄ ENHANCED BACKTEST ENGINE STARTING...")
    print("="*50)
    
    result = enhanced_run_backtest(
        mode=RUN_MODE, 
        config_id=CONFIG_ID, 
        custom_config=CUSTOM_CONFIG,
        validate=True  # Enable validation
    )
    
    if result:
        print("\n‚úÖ Enhanced backtest completed successfully!")
    else:
        print("\n‚ùå Enhanced backtest failed or was cancelled.")